import 'package:flutter/material.dart';
import 'package:study_quest/pages/event_editing_page.dart';
import 'package:study_quest/widgets/app_drawer.dart';
import 'package:study_quest/widgets/calendar_widget.dart';
import 'package:study_quest/providers/event_provider.dart';
import 'package:study_quest/providers/subject_provider.dart';
import 'package:provider/provider.dart';

import '../models/event.dart';

class CalendarPage extends StatefulWidget {
  @override
  _CalendarPageState createState() => _CalendarPageState();
}

class _CalendarPageState extends State<CalendarPage> {
  @override
  Widget build(BuildContext context) {
    String selectedPage = 'Página Inicial';

    return Scaffold(
      appBar: AppBar(
        title: const Text('Página Inicial'),
        actions: [
          IconButton(
            icon: Icon(Icons.schedule),
            onPressed: () => _generateBalancedWeeklySchedule(context), // Botão para gerar o cronograma equilibrado
          ),
        ],
      ),
      drawer: AppDrawer(
        selectedPage: selectedPage,
        onItemSelected: (String page) {
          setState(() => selectedPage = page);
        },
      ),
      body: CalendarWidget(),
      floatingActionButton: FloatingActionButton(
        onPressed: () => Navigator.of(context)
            .push(MaterialPageRoute(builder: (context) => EventEditingPage())),
        child: Icon(Icons.add),
      ),
    );
  }

void _generateBalancedWeeklySchedule(BuildContext context) async {
  final eventProvider = Provider.of<EventProvider>(context, listen: false);
  final subjectProvider = Provider.of<SubjectProvider>(context, listen: false);

  // Remover eventos gerados automaticamente anteriores
  eventProvider.removeAutoGeneratedEvents();

  // Obter as disciplinas e suas horas semanais
  final subjects = subjectProvider.subjects;

  // Calcular o tempo total de estudo semanal
  double totalWeeklyStudyTime = 0;
  for (var subject in subjects) {
    final int hours = subject['hours'];
    totalWeeklyStudyTime += hours.toDouble();
  }

  // Calcular o tempo de estudo diário (total semanal dividido por 6 dias)
  final double dailyStudyTime = totalWeeklyStudyTime / 6;

  // Mapa para armazenar o tempo restante de estudo de cada disciplina
  final Map<String, double> weeklyStudyTime = {};
  for (var subject in subjects) {
    final String name = subject['name'];
    final int hours = subject['hours'];
    weeklyStudyTime[name] = hours.toDouble(); // Horas semanais de cada disciplina
  }

  // Adicionar os horários de estudo no calendário (de segunda a sábado)
  DateTime currentDate = DateTime.now();
  while (currentDate.weekday > DateTime.saturday) {
    currentDate = currentDate.add(Duration(days: 1)); // Avançar para a próxima segunda-feira
  }

  // Lista de disciplinas para intercalar
  List<String> subjectsList = weeklyStudyTime.keys.toList();

  // Distribuir as horas de estudo ao longo da semana
  for (int day = 0; day < 6; day++) { // Segunda a sábado
    DateTime startTime = DateTime(currentDate.year, currentDate.month, currentDate.day, 7); // Começa às 7h
    DateTime endTime = startTime.add(Duration(hours: 1)); // Blocos de 1 hora

    double dailyStudyTimeRemaining = dailyStudyTime; // Tempo de estudo restante para o dia

    // Intercalar as disciplinas ao longo do dia
    while (dailyStudyTimeRemaining > 0 && startTime.hour < 19) { // Até às 19h
      for (int i = 0; i < subjectsList.length; i++) {
        String subject = subjectsList[i];
        double studyTime = weeklyStudyTime[subject]!;

        // Verificar se ainda há tempo de estudo para a disciplina
        if (studyTime > 0) {
          // Verificar se o horário está disponível (considerando eventos existentes)
          if (eventProvider.isTimeSlotAvailable(startTime, endTime)) {
            // Obter a cor da disciplina
            final subjectData = subjects.firstWhere((s) => s['name'] == subject);
            final Color subjectColor = Color(subjectData['color']);

            eventProvider.addEvent(Event(
              title: subject,
              from: startTime,
              to: endTime,
              backgroundColor: subjectColor, // Usar a cor da disciplina
              isAllDay: false,
              isAutoGenerated: true, // Marcar como gerado automaticamente
            ));

            // Reduzir o tempo de estudo restante para a disciplina e para o dia
            weeklyStudyTime[subject] = studyTime - 1;
            dailyStudyTimeRemaining -= 1;

            // Avançar para o próximo bloco de tempo
            startTime = endTime;
            endTime = startTime.add(Duration(hours: 1));
          } else {
            // Se o horário não estiver disponível, avançar para o próximo bloco de tempo
            startTime = startTime.add(Duration(hours: 1));
            endTime = endTime.add(Duration(hours: 1));
          }

          // Verificar se o horário ultrapassou o limite do dia
          if (startTime.hour >= 19) {
            break; // Sair do loop se o horário ultrapassar as 19h
          }
        }
      }

      // Verificar se o tempo de estudo diário foi concluído
      if (dailyStudyTimeRemaining <= 0) {
        break; // Sair do loop se o tempo diário foi atingido
      }

      // Adicionar um pequeno delay para evitar bloqueio da thread principal
      await Future.delayed(Duration(milliseconds: 10));
    }

    currentDate = currentDate.add(Duration(days: 1)); // Avançar para o próximo dia
  }

  ScaffoldMessenger.of(context).showSnackBar(
    SnackBar(content: Text('Cronograma semanal equilibrado gerado com sucesso!')),
  );
}
}
